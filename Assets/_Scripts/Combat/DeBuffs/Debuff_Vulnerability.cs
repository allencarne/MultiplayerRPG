using System.Collections;
using TMPro;
using Unity.Netcode;
using UnityEngine;

public class Debuff_Vulnerability : NetworkBehaviour
{
    [SerializeField] CharacterStats stats;
    [SerializeField] Enemy enemy;
    [SerializeField] Buffs buffs;

    [SerializeField] GameObject debuffBar;
    [SerializeField] GameObject debuff_Vulnerability;

    [HideInInspector] public float vulnerabilityPercent = 0.036f;
    [HideInInspector] public int VulnerabilityStacks;
    GameObject durationVulnerabilityUI = null;
    GameObject conditionalVulnerabilityUI = null;
    float vulnerabilityElapsed = 0f;
    float vulnerabilityTotal = 0f;
    int durationVulnerabilityStacks = 0;
    int conditionalVulnerabilityStacks = 0;
    public int TotalVulnerabilityStacks => durationVulnerabilityStacks + conditionalVulnerabilityStacks;
    bool IsVulnerable => TotalVulnerabilityStacks > 0;

    private void Update()
    {
        UpdateVulnerabilityUI();
    }

    public void StartVulnerability(int stacks, float? duration = null)
    {
        if (!IsOwner) return;

        if (IsServer)
        {
            if (duration.HasValue)
                StartCoroutine(Initialize(stacks, duration.Value));
        }
        else
        {
            if (duration.HasValue)
                RequestServerRPC(stacks, duration.Value);
        }
    }

    [ServerRpc]
    void RequestServerRPC(int stacks, float duration)
    {
        StartCoroutine(Initialize(stacks, duration));
    }

    IEnumerator Initialize(int stacks, float duration)
    {
        durationVulnerabilityStacks += stacks;
        durationVulnerabilityStacks = Mathf.Min(durationVulnerabilityStacks, 25);

        UpdateVulnerabilityUI();
        CalculateArmor();

        if (duration > vulnerabilityTotal - vulnerabilityElapsed)
        {
            BroadcastClientRPC(durationVulnerabilityStacks, duration);
        }

        yield return new WaitForSeconds(duration);

        durationVulnerabilityStacks -= stacks;
        durationVulnerabilityStacks = Mathf.Max(durationVulnerabilityStacks, 0);

        UpdateVulnerabilityUI();
        CalculateArmor();

        BroadcastClientRPC(durationVulnerabilityStacks);
    }

    [ClientRpc]
    void BroadcastClientRPC(int stacks, float remaining = -1f)
    {
        if (stacks > 0)
        {
            if (durationVulnerabilityUI == null)
                durationVulnerabilityUI = Instantiate(debuff_Vulnerability, debuffBar.transform);

            durationVulnerabilityUI.GetComponentInChildren<TextMeshProUGUI>().text = stacks.ToString();

            if (remaining > 0f)
            {
                vulnerabilityElapsed = 0f;
                vulnerabilityTotal = remaining;
            }
        }
        else
        {
            if (durationVulnerabilityUI != null)
            {
                Destroy(durationVulnerabilityUI);
                durationVulnerabilityUI = null;
            }

            vulnerabilityElapsed = 0f;
            vulnerabilityTotal = 0f;
        }
    }

    void CalculateArmor()
    {
        float protectionMultiplier = buffs.protection.TotalProtectionStacks * buffs.protection.protectionPercent;
        float vulnerabilityMultiplier = TotalVulnerabilityStacks * vulnerabilityPercent;
        float multiplier = 1 + protectionMultiplier - vulnerabilityMultiplier;

        if (stats != null)
        {
            float armor = stats.Armor.Value * multiplier;
            stats.Armor.Value = Mathf.Max(armor, 0.1f);
        }

        if (enemy != null)
        {
            float armor = enemy.BaseArmor * multiplier;
            enemy.CurrentArmor = Mathf.Max(armor, 0.1f);
        }
    }

    void UpdateVulnerabilityUI()
    {
        if (vulnerabilityTotal > 0f && durationVulnerabilityUI != null)
        {
            vulnerabilityElapsed += Time.deltaTime;
            float fill = Mathf.Clamp01(vulnerabilityElapsed / vulnerabilityTotal);

            var ui = durationVulnerabilityUI.GetComponent<StatusEffects>();
            if (ui != null) ui.UpdateFill(fill);
        }
    }

    public void StartConditionalVulnerability(int stacks)
    {
        if (!IsOwner) return;

        if (IsServer)
        {
            InitializeConditional(stacks);
        }
        else
        {
            RequestConditionalServerRPC(stacks);
        }
    }

    [ServerRpc]
    void RequestConditionalServerRPC(int stacks)
    {
        InitializeConditional(stacks);
    }

    void InitializeConditional(int stacks)
    {
        conditionalVulnerabilityStacks += stacks;
        conditionalVulnerabilityStacks = Mathf.Clamp(conditionalVulnerabilityStacks, 0, 25);

        UpdateVulnerabilityUI();
        CalculateArmor();
        BroadcastConditionalClientRPC(conditionalVulnerabilityStacks);
    }

    [ClientRpc]
    void BroadcastConditionalClientRPC(int stacks)
    {
        if (stacks > 0)
        {
            if (conditionalVulnerabilityUI == null)
                conditionalVulnerabilityUI = Instantiate(debuff_Vulnerability, debuffBar.transform);

            conditionalVulnerabilityUI.GetComponentInChildren<TextMeshProUGUI>().text = stacks.ToString();
        }
        else
        {
            if (conditionalVulnerabilityUI != null)
            {
                Destroy(conditionalVulnerabilityUI);
                conditionalVulnerabilityUI = null;
            }
        }
    }
}
